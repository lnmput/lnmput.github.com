<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"swoole.app","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="要么庸俗，要么孤独">
<meta property="og:type" content="website">
<meta property="og:title" content="杨子鳄鱼 ● 外贸自建站">
<meta property="og:url" content="https://swoole.app/index.html">
<meta property="og:site_name" content="杨子鳄鱼 ● 外贸自建站">
<meta property="og:description" content="要么庸俗，要么孤独">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lnmput@gmail.com">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://swoole.app/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>杨子鳄鱼 ● 外贸自建站</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">杨子鳄鱼 ● 外贸自建站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">专注外贸独立站建设</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section">首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags" rel="section">标签</a></li>
        <li class="menu-item menu-item-读书"><a href="/read" rel="section">读书</a></li>
        <li class="menu-item menu-item-翻译"><a href="/tags/translate" rel="section">翻译</a></li>
        <li class="menu-item menu-item-关于我"><a href="/about" rel="section">关于我</a></li>
        <li class="menu-item menu-item-外贸站"><a href="/site" rel="section">外贸站</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lnmput@gmail.com"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">lnmput@gmail.com</p>
  <div class="site-description" itemprop="description">要么庸俗，要么孤独</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">412</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">134</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="http://www.laruence.com/" title="风雪之隅 → http:&#x2F;&#x2F;www.laruence.com&#x2F;" rel="noopener" target="_blank">风雪之隅</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://tech.youzan.com/" title="有赞技术团队 → http:&#x2F;&#x2F;tech.youzan.com&#x2F;" rel="noopener" target="_blank">有赞技术团队</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://tech.meituan.com/archives" title="美团点评技术团队 → https:&#x2F;&#x2F;tech.meituan.com&#x2F;archives" rel="noopener" target="_blank">美团点评技术团队</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://macshuo.com/" title="點燈坊 → http:&#x2F;&#x2F;macshuo.com&#x2F;" rel="noopener" target="_blank">點燈坊</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.turn.tw/" title="轉個彎日誌 → http:&#x2F;&#x2F;blog.turn.tw&#x2F;" rel="noopener" target="_blank">轉個彎日誌</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lnmput" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/27/Dockerize-Go-Application-Easily/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/27/Dockerize-Go-Application-Easily/" class="post-title-link" itemprop="url">Dockerize-Go-Application-Easily</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-27 13:01:37 / 修改时间：13:38:15" itemprop="dateCreated datePublished" datetime="2022-08-27T13:01:37+09:00">2022-08-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
When you become a parent, one thing becomes really clear. <br>
And that's that you want to make sure your children feel safe.
</blockquote>

<p>There are some ways to deploy your Golang code, especially when you are using Docker to run your executable file of your Go Project. We can create our image from our project, and we can simply run it on your local computer, or even on the deployment by pulling your image from the registry.</p>
<h3 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h3><ul>
<li>docker</li>
<li>Basic of Go Programming<br>Repository: <a target="_blank" rel="noopener" href="https://github.com/david-yappeter/go-dockerfile-example">https://github.com/david-yappeter/go-dockerfile-example</a></li>
</ul>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>First, you need to start your docker daemon by using <code>systemctl start docker</code> or <code>service docker start</code> , use <code>sudo</code> if needed.</p>
<p>Then we will create our simple go HTTP code.</p>
<p>Then we will create our simple go HTTP code.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="keyword">go</span>-dockerfile &amp;&amp; cd <span class="keyword">go</span>-dockerfile</span><br><span class="line">$ <span class="keyword">go</span> mod init myapp</span><br><span class="line">$ touch server.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>server.go:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/joho/godotenv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	godotenv.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	port := os.Getenv(<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		port = <span class="string">&quot;8080&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/env&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">&quot;Hello %s&quot;</span>, os.Getenv(<span class="string">&quot;NAME&quot;</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Run(<span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our <code>server.go</code> will contain a simple <code>gin</code> router and optional <code>godotenv</code> .</p>
<p><code>/</code> path will return “Hello World” and <code>/env</code> path will return “Hello ${NAME}”.</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>there are several ways to write <code>Dockerfile</code> , but I will make 3 examples with different base images: official golang, alpine, and scratch.</p>
<h4 id="FROM-Official-Image"><a href="#FROM-Official-Image" class="headerlink" title="FROM Official Image"></a>FROM Official Image</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:<span class="number">1.16</span>-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /project/<span class="keyword">go</span>-docker/</span><br><span class="line"></span><br><span class="line"># COPY <span class="keyword">go</span>.mod, <span class="keyword">go</span>.sum and download the dependencies</span><br><span class="line">COPY <span class="keyword">go</span>.* ./</span><br><span class="line">RUN <span class="keyword">go</span> mod download</span><br><span class="line"></span><br><span class="line"># COPY All things inside the project and build</span><br><span class="line">COPY . .</span><br><span class="line">RUN <span class="keyword">go</span> build -o /project/<span class="keyword">go</span>-docker/build/myapp .</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">8080</span></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;/project/go-docker/build/myapp&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>In this Dockerfile , we will split it into some sections:</p>
<ul>
<li><code>FROM golang:1.16-alpine</code> , we will use golang:1.16-alpine as the base image of this Docker build.</li>
<li><code>WORKDIR</code> , will be our working directory of our command/path of our next commands.</li>
<li><code>COPY go.* ./</code> , we will copy <code>go.mod</code> &amp; <code>go.sum</code> file from our project to the working directory.</li>
<li><code>RUN go mod download</code> , download the project dependencies from go modules.</li>
<li><code>COPY . .</code> , copy all things from our project into the working directory.</li>
<li><code>RUN go build -o /project/go-docker/build/myapp .</code> , build our project in the working directory and output it in <code>project/go-docker/build/myapp</code> as a binary file.</li>
<li><code>EXPOSE 8080</code> , telling docker that our code will expose port 8080 .</li>
<li><code>ENTRYPOINT [&quot;/project/go-docker/build/myapp&quot;]</code> , when we run the container of this image, it will start from our build binary.</li>
</ul>
<p>Any of these duplicate explanations won’t be explained twice. After this we need to run this command:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile -t test-go-docker:latest .</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-f</code> flag is the filename of our Dockerfile .</p>
</li>
<li><p><code>-t</code> flag is the name of the image later on.</p>
</li>
<li><p><code>.</code> at the end of the command is the directory of the Dockerfile .</p>
</li>
</ul>
<h4 id="Alpine-Base-Image"><a href="#Alpine-Base-Image" class="headerlink" title="Alpine Base Image"></a>Alpine Base Image</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:<span class="number">1.16</span>-alpine as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /project/<span class="keyword">go</span>-docker/</span><br><span class="line"></span><br><span class="line"># COPY <span class="keyword">go</span>.mod, <span class="keyword">go</span>.sum and download the dependencies</span><br><span class="line">COPY <span class="keyword">go</span>.* ./</span><br><span class="line">RUN <span class="keyword">go</span> mod download</span><br><span class="line"></span><br><span class="line"># COPY All things inside the project and build</span><br><span class="line">COPY . .</span><br><span class="line">RUN <span class="keyword">go</span> build -o /project/<span class="keyword">go</span>-docker/build/myapp .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">COPY --from=builder /project/<span class="keyword">go</span>-docker/build/myapp /project/<span class="keyword">go</span>-docker/build/myapp</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">8080</span></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;/project/go-docker/build/myapp&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>The difference from the first one:</p>
<ul>
<li><code>FROM golang:1.16-alpine as builder</code> , we will use golang:1.16-alpine and tag it as builder that later on will be used.</li>
<li><code>FROM alpine:latest</code> , we will create a new base image from alpine .</li>
<li><code>COPY --from=builder /project/go-docker/build/myapp /project/go-docker/build/myapp</code> , copy the build binary file into the new alpine image and run it later on.<br>The image size of this <code>Dockerfile</code> is way smaller than the previous image.</li>
</ul>
<h4 id="FROM-Scratch"><a href="#FROM-Scratch" class="headerlink" title="FROM Scratch"></a>FROM Scratch</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.16-alpine as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /project/go-docker/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COPY go.mod, go.sum and download the dependencies</span></span><br><span class="line">COPY go.* ./</span><br><span class="line">RUN go mod download</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COPY All things inside the project and build</span></span><br><span class="line">COPY . .</span><br><span class="line">RUN go build -o /project/go-docker/build/myapp .</span><br><span class="line"></span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=builder /project/go-docker/build/myapp /project/go-docker/build/myapp</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [ &quot;/project/go-docker/build/myapp&quot; ]</span><br></pre></td></tr></table></figure>
<p>And for the last Dockerfile, we only change the alpine base image into scratch . Scratch is an empty image, so once the container running, we can’t exec into the container because it doesn’t even have a shell command.</p>
<p>The image is slightly smaller than the alpine base image.</p>
<p>try to run the image by using <code>docker run -d -p 8080:8080 test-go-docker:latest</code> , it will forward port <code>8080</code> from the container to our <code>8080</code> port and access the <code>http://localhost:8080</code> .</p>
<h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><p>Personally, I will choose the second Dockerfile . Why? because the size is small and it still has several commands and a shell command so we can docker exec into the container and access it. If we use the scratch base image, it will be hard for us to debug our running container because we can’t exec into it.</p>
<p>That’s all for this article about Docker with Go Programming, hope you have a nice day :).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/27/Building-a-Golang-application-Docker-image/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/27/Building-a-Golang-application-Docker-image/" class="post-title-link" itemprop="url">Building-a-Golang-application-Docker-image</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-27 12:47:52 / 修改时间：13:00:17" itemprop="dateCreated datePublished" datetime="2022-08-27T12:47:52+09:00">2022-08-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
We'll find a way; we always have.
</blockquote>


<p>After we have written the application after several months of hard work, how to deploy it? Let’s use a simple example of Hello Worldto learn.</p>
<p>The project structure is as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">go</span>.mod</span><br><span class="line">└── hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>The code content of hello.gois as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In order to keep up with the trend, we choose to use Docker deployment here.</p>
<h3 id="First-attempt"><a href="#First-attempt" class="headerlink" title="First attempt."></a>First attempt.</h3><p>For convenience, we are going to put all the content into Docker for compilation, and after some research, we get the following <code>Dockerfile</code> file:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:alpine</span><br><span class="line">WORKDIR /build</span><br><span class="line">COPY hello.<span class="keyword">go</span> .</span><br><span class="line">RUN <span class="keyword">go</span> build -o hello hello.<span class="keyword">go</span></span><br><span class="line">CMD [<span class="string">&quot;./hello&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>Next start building.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t hello:v1 .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm hello:v1 ls -l /build</span></span><br><span class="line">total 1260</span><br><span class="line">-rwxr-xr-x    1 root     root       1281547 Mar  6 15:54 hello</span><br><span class="line">-rw-r--r--    1 root     root            55 Mar  6 14:59 hello.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> try to run it</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm hello:v1</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>It runs successfully, and then we look at the size of the image.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images | grep hello</span></span><br><span class="line">hello         v1    2783ee221014   44 minutes ago   314MB</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">Shocked me, the whole image actually has 314MB, just docker build, what happened?</span><br><span class="line"></span><br><span class="line">Although it can be run, the size of this image is too scary, we just simply printed a line of hello world, and the size of the image is more than 300 MB, which is too unreasonable and needs to be optimized.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Second attempt.</span></span></span><br><span class="line">After looking for the information, I found that the base image we used was too large.</span><br><span class="line"></span><br><span class="line">```golang</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker images | grep golang</span></span><br><span class="line">golang    alpine     d026981a7165   2 days ago          313MB</span><br></pre></td></tr></table></figure>

<p>A friend told me that I can compile the code first, and then copy it in, so I don’t need that huge base image, but it’s easy to say, I still spent some time learning, and finally the <code>Dockerfile</code> looks like this:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">WORKDIR /build</span><br><span class="line">COPY hello .</span><br><span class="line">CMD [<span class="string">&quot;./hello&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>Let’s rebuild the image:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t hello:v2 .</span><br><span class="line">...</span><br><span class="line">=&gt; ERROR [<span class="number">3</span>/<span class="number">3</span>] COPY hello .                         <span class="number">0.0</span>s</span><br><span class="line">------</span><br><span class="line">&gt; [<span class="number">3</span>/<span class="number">3</span>] COPY hello .:</span><br><span class="line">------</span><br><span class="line">failed to compute cache key: <span class="string">&quot;/hello&quot;</span> not found: not found</span><br></pre></td></tr></table></figure>
<p>Oh hoo, wrong report. The prompt hello cannot be found, so I forgot to compile hello.go first and execute it again.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -o hello hello.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm hello:v2</span></span><br><span class="line">standard_init_linux.go:228: exec user process caused: exec format error</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">Whoops, failed again.</span><br><span class="line"></span><br><span class="line">Well, the format is wrong, it turns out that our development machine is not linux, Don’t give up, let’s do it again.</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">$</span><span class="bash"> GOOS=linux go build -o hello hello.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t hello:v2 .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">Successfully</span><br></pre></td></tr></table></figure>

<p>Finally, the build is successful, let’s try it out.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm hello:v2</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>No problem, let’s take a look at the content and size.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm hello:v2 ls -l /build</span><br><span class="line">total <span class="number">1252</span></span><br><span class="line">-rwxr-xr-x    <span class="number">1</span> root     root       <span class="number">1281587</span> Mar  <span class="number">6</span> <span class="number">16</span>:<span class="number">18</span> hello</span><br><span class="line"></span><br><span class="line">$ docker images | grep hello</span><br><span class="line">hello    v2   <span class="number">0</span>dd53f016c93   <span class="number">53</span> seconds ago      <span class="number">6.61</span>MB</span><br><span class="line">hello    v1   ac0e37173b85   <span class="number">25</span> minutes ago      <span class="number">314</span>MB</span><br></pre></td></tr></table></figure>

<p>Wow, it’s only 6.61MB this time, which is OK!</p>
<h3 id="Third-attempt"><a href="#Third-attempt" class="headerlink" title="Third attempt."></a>Third attempt.</h3><p>Although the above image can be successfully built, there are still some shortcomings. It is not a multi-stage build.</p>
<p>We need to be able to build a docker image from Go code, which is divided into three steps:</p>
<ul>
<li>Compile Go code natively, if it involves cgo the cross-platform compilation will be more troublesome.</li>
<li>Build a docker image with the compiled executable.</li>
<li>Write a shell script or makefile to get these steps in one command.<br>Multi-stage builds are all about putting it all into one <code>Dockerfile</code>, no source code leaks, no scripting for cross-platform compilation, and a minimal image.</li>
</ul>
<p>Loving to learn and striving for perfection, I ended up writing the following <code>Dockerfile</code>.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:alpine AS builder</span><br><span class="line">WORKDIR /build</span><br><span class="line">ADD <span class="keyword">go</span>.mod .</span><br><span class="line">COPY . .</span><br><span class="line">RUN <span class="keyword">go</span> build -o hello hello.<span class="keyword">go</span></span><br><span class="line">FROM alpine</span><br><span class="line">WORKDIR /build</span><br><span class="line">COPY --from=builder /build/hello /build/hello</span><br><span class="line">CMD [<span class="string">&quot;./hello&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>The first FROM starts with building a builder image in which the executable hellois compiled.</p>
<p>The part starting with the second FROM is to copy the executable hello from the first image, and use the smallest possible base image alpine to ensure that the final image is as small as possible.</p>
<p>As for why you don’t use a smaller scratch, it’s because there’s really nothing in scratch, and there is no chance to take a look if there is a problem, and alpine is only 5MB, which is good for our service will not have much impact.</p>
<p>Let’s run it first to verify:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm hello:v3</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>No problem, as expected! See what the size looks like:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images | grep hello</span></span><br><span class="line">hello    v3     f51e1116be11   8 hours ago    6.61MB</span><br><span class="line">hello    v2     0dd53f016c93   8 hours ago    6.61MB</span><br><span class="line">hello    v1     ac0e37173b85   8 hours ago    314MB</span><br></pre></td></tr></table></figure>
<p>The size of the image built by the second method is exactly the same. Take a look at the contents of the mirror:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm hello:v3 ls -l /build</span><br><span class="line">total <span class="number">1252</span></span><br><span class="line">-rwxr-xr-x    <span class="number">1</span> root     root       <span class="number">1281547</span> Mar  <span class="number">6</span> <span class="number">16</span>:<span class="number">32</span> hello</span><br></pre></td></tr></table></figure>

<p>Also, only one executable hello file builds perfectly!</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.devgenius.io/tutorial-building-a-golang-application-docker-image-78e36d437c70">https://blog.devgenius.io/tutorial-building-a-golang-application-docker-image-78e36d437c70</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/25/Golang%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/25/Golang%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Golang自动化实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-25 12:09:45 / 修改时间：12:19:07" itemprop="dateCreated datePublished" datetime="2022-08-25T12:09:45+09:00">2022-08-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
私（わたし）が年（とし）をとっても仲良（なかよ）くしてください。
</blockquote>


<h3 id="ライブラリの紹介"><a href="#ライブラリの紹介" class="headerlink" title="ライブラリの紹介"></a>ライブラリの紹介</h3><p>今回見つけたライブラリは、<br>Robotgo<br>です。<br>Robotgoは、<br>Go言語でのデスクトップオートメーション。マウス、キーボード、ビットマップ、<br>画像を制御し、画面、プロセス、ウィンドウハンドル、グローバルイベントリスナーを読み取りが行える。<br>ライブラリです。<br>対応するOSは、<br>Windows、Mac、Linux<br>のようで、64bit/32bit両方に対応しています。</p>
<h3 id="環境構築"><a href="#環境構築" class="headerlink" title="環境構築"></a>環境構築</h3><p>今回、Windows、Linuxで動かしてみました。<br>それぞれの環境構築手順をまとめておきたいと思います。<br>なお、Windows、Linuxの詳細ですが、<br>Windows：Windows 10<br>Linux：Ubuntu20.04<br>を用いてみました。</p>
<p>まず、Robotgoをインストールする前の下準備をまとめておきます。</p>
<p>最初にWindowsの環境構築手順に関してまとめたいと思います。<br>といってもWIndowの場合、<br>MinGW-w64<br>をインストールするのみです。<br>すでにインストール済みでしたら他の作業は不要です。<br>インストール手順は下記にまとまっていますのでこちらをご参考にしてください。<br>といっても、インストーラを用いてインストールしてパスを通すのみなので簡単。<br><a target="_blank" rel="noopener" href="https://www.javadrive.jp/cstart/install/index6.html">https://www.javadrive.jp/cstart/install/index6.html</a></p>
<p>後、もしかしたら下記が必要になるかもです。<br>(自分は必要でした)</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/lxn/win</span><br></pre></td></tr></table></figure>
<p>次にLinux。<br>今回Ubuntuを用いたのでUbuntuの手順をまとめます。<br>下記ライブラリをapt-get する。以上です。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc libc6-dev</span><br><span class="line">sudo apt install libx11-dev xorg-dev libxtst-dev libpng ++-dev</span><br><span class="line">sudo apt install xcb libxcb-xkb-dev x11-xkb-utils libx11-xcb-dev libxkbcommon-x11-dev </span><br><span class="line">sudo apt install libxkbcommon-dev</span><br><span class="line">sudo apt install xsel xclip</span><br></pre></td></tr></table></figure>
<p>後は、Windows、Linuxどちらも</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/<span class="keyword">go</span>-vgo/robotgo</span><br></pre></td></tr></table></figure>
<p>でインストールするのみです。</p>
<h3 id="マウス操作自動化"><a href="#マウス操作自動化" class="headerlink" title="マウス操作自動化"></a>マウス操作自動化</h3><p>では早速、マウス操作の自動化コードを作成してみます。<br>といっても今回は公式がご紹介しているサンプルを載せておきます。<br>公式：<a target="_blank" rel="noopener" href="https://github.com/go-vgo/robotgo">https://github.com/go-vgo/robotgo</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/go-vgo/robotgo&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  robotgo.ScrollMouse(<span class="number">10</span>, <span class="string">&quot;up&quot;</span>)</span><br><span class="line">  robotgo.Scroll(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.MoveMouse(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">  robotgo.Drag(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.MouseClick(<span class="string">&quot;left&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">  robotgo.MoveMouseSmooth(<span class="number">100</span>, <span class="number">200</span>, <span class="number">1.0</span>, <span class="number">100.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robotgo.ScrollMouse(<span class="number">10</span>, <span class="string">&quot;up&quot;</span>)</span><br><span class="line">robotgo.Scroll(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>でマウスのスクロールを行い、</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robotgo.MoveMouse(<span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>でマウスを移動させ、</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robotgo.MouseClick(<span class="string">&quot;left&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>でマウスの左クリックを押下する。</p>
<h3 id="キーボード入力"><a href="#キーボード入力" class="headerlink" title="キーボード入力"></a>キーボード入力</h3><p>次はキーボード入力です。<br>こちらは公式で展開しているサンプルから少し変更を行い、</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello WorldだんしゃりHi galaxy. こんにちは世界.</span><br></pre></td></tr></table></figure>
<p>という文字を入力後、テキストファイルを保存する処理になります。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;だんしゃり&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;Hi galaxy. こんにちは世界.&quot;</span>)</span><br><span class="line">  robotgo.Sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.KeyTap(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">  robotgo.KeyTap(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;ctrl&quot;</span>)</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;こんにちは世界.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.KeyTap(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.WriteAll(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">  text, err := robotgo.ReadAll()</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;だんしゃり&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">  robotgo.TypeStr(<span class="string">&quot;Hi galaxy. こんにちは世界.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>でキーボードによる文字入力を行い、</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robotgo.KeyTap(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">robotgo.KeyTap(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;ctrl&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>で特定のキーボードをタップする形になります。</p>
<p>PyAutoGuiで言うところの、<br>pyautogui.write関数が、robotgo.TypeStr関数に該当し、<br>pyautogui.press関数が、robotgo.KeyTapに該当します。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robotgo.WriteAll(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">text, err := robotgo.ReadAll()</span><br></pre></td></tr></table></figure>
<p>こちらは内部メモリへの文字列書き込みと読み出しを行う処理のようです。</p>
<h3 id="■最後に"><a href="#■最後に" class="headerlink" title="■最後に"></a>■最後に</h3><p>今回はgo言語で自動化が行える、Robotgoに関する環境構築や簡単なキーボード・マウス操作に関してまとめてみました。<br>ちょっと長くなってきたので今回はここまでとします。</p>
<p>まだ画像認識やイベント操作などが書けていないので、次回まとめたいと思います。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://elsammit-beginnerblg.hatenablog.com/entry/2021/10/03/095838">https://elsammit-beginnerblg.hatenablog.com/entry/2021/10/03/095838</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/21/Golang%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/21/Golang%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Golang中的原子操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-21 23:57:16" itemprop="dateCreated datePublished" datetime="2022-08-21T23:57:16+09:00">2022-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-22 12:27:58" itemprop="dateModified" datetime="2022-08-22T12:27:58+09:00">2022-08-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
Love means never having to say you're sorry. 
</blockquote>


<p>With it easy to use go routines, you have unbridled power to harness concurrency in your programs. However, Go is not spared from race conditions. We still have to use mutex and atomic constructs to ensure that shared variables and their state are correct when read/write by go routines. The aim of this article is to see what could go wrong if you are not careful and how to avoid race conditions in your code.</p>
<p>Let’s create a simple program to demonstrate a shared variable.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mutexAtomicExample</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//needed so that the function don&#x27;t   </span></span><br><span class="line">                              <span class="comment">//exit prematurely relative </span></span><br><span class="line">                              <span class="comment">//to all go routines</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        count++</span><br><span class="line">                &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;count: %v for 100000 cycles\n&quot;</span>, count) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the increment function above, we use create 100,000 go routines where each of these will increment the count variable. We use a waitgroup to ensure the main program stays blocked [at the wg.Wait() line] until all the go routines have the chance to run till completion.</p>
<p>Surprisingly, the output is as follows if we run the increment function.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count: <span class="number">98152</span> <span class="keyword">for</span> <span class="number">100000</span> cycles</span><br></pre></td></tr></table></figure>
<p>What gives?? Turns out that despite the waitgroup, the increment count operations carried out by each go routine may not be successful. The increment operation is not atomic, meaning that it could be interrupted midway by another go routine that is working concurrently to increment the same count variable. Hence, you won’t have count that will reach 100,000 but less than that. At the high level, this is a race condition.</p>
<p>Two ways to handle — Mutex and Atomic Construct</p>
<p>In the first way, we use mutex to lock the shared variable such that only one go routine can increment the count at a time.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncrementMutex</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup </span><br><span class="line">	m := sync.Mutex&#123;&#125; <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">	        wg.Add(<span class="number">1</span>)</span><br><span class="line">	        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">	                m.Lock()</span><br><span class="line">	                <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">	                count++</span><br><span class="line">	        &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;count: %v for 100000 cycles with Mutex\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In //(1), we create a variable mutex with the sync.Mutex{} structure which will give a zero value mutex. This will by default be an unlocked mutex.</p>
<p>In the go routine, we lock the mutex before the increment of the count and unlock thereafter. And below is the output of running the function.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count: <span class="number">100000</span> <span class="keyword">for</span> <span class="number">100000</span> cycles with Mutex</span><br></pre></td></tr></table></figure>

<p>Now, let’s try to use the atomic construct which is available as part of the sync/atomic. Again we create a variant of the increment function:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncrementAtomic</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">int64</span> <span class="comment">// sync atomic cannot work with int (1)</span></span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        atomic.AddInt64(&amp;count, <span class="number">1</span>) <span class="comment">//(2)</span></span><br><span class="line">                &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;count: %v for 100000 cycles with Atomic\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice in (1), we had to use a int64 instead of the int since the atomic package cannot work with int. We can also use int32. Below are some functions showing the specific integer types that will work. So be sure to check the official documentations before using the sync/atomic package.</p>
<ul>
<li><code>func AddInt32(addr *int32, delta int32) (new int32)</code></li>
<li><code>func AddInt64(addr *int64, delta int64) (new int64)</code></li>
<li><code>func AddUint32(addr *uint32, delta uint32) (new uint32)</code></li>
<li><code>func AddUint64(addr *uint64, delta uint64) (new uint64)</code></li>
<li><code>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</code></li>
</ul>
<p>In //(2), we evoke the AddInt64 function which requires the int64 variable as the first parameter and the delta value (also another int64) that we want to add to it.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://medium.com/@naikofficial56/concurrency-with-golang-7d8e0c65ef85">https://medium.com/@naikofficial56/concurrency-with-golang-7d8e0c65ef85</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://medium.com/@naikofficial56/concurrency-with-golang-7d8e0c65ef85">https://medium.com/@naikofficial56/concurrency-with-golang-7d8e0c65ef85</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/15/Go-Programming-I-Pointers-in-Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/Go-Programming-I-Pointers-in-Golang/" class="post-title-link" itemprop="url">Go-Programming-I-Pointers-in-Golang</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-15 11:19:11 / 修改时间：11:29:44" itemprop="dateCreated datePublished" datetime="2022-08-15T11:19:11+09:00">2022-08-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
Bond。James Bond。
</blockquote>

<p>A pointer is a special type that is used to reference a value. Understanding it better can help you write advanced code in Go.</p>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>Computer memory can be thought of as a sequence of boxes, placed one after another in a line. Each box is labeled with a unique number, which increments sequentially. The unique location number is called a memory address.</p>
<img style="margin-left: 0;" src="/images/golangpointer001.png">

<p>A variable is just a convenient, alphanumeric nickname for a piece of memory location assigned by the compiler. When you declare variables, you are given a memory location to use from the free memory available.</p>
<img style="margin-left: 0;" src="/images/golangpointer002.png">

<h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><p>A pointer value is the address of a variable. A pointer is thus the location at which a value is stored. With a pointer, we can read or update the value of a variable indirectly, without using or even knowing the variable’s name, if indeed it has a name.</p>
<p>In the following example,</p>
<ul>
<li>The statement &amp;x yields a pointer to an integer variable.</li>
<li>y := &amp;x We say y points to x, or y contains the address of x.</li>
<li>The expression <code>*y</code> yields the value of that integer variable, which is 9 here.</li>
</ul>
<img style="margin-left: 0;" src="/images/golangpointer003.png">

<h3 id="Why-is-pointer-useful"><a href="#Why-is-pointer-useful" class="headerlink" title="Why is pointer useful?"></a>Why is pointer useful?</h3><blockquote>
<p>“Pointers are used for efficiency because everything in Go is passed by value so they let us pass an address where data is held instead of passing the data’s value, to avoid unintentionally changing data, and so we can access an actual value in another function and not just a copy of it when we want to mutate it.”</p>
</blockquote>
<h3 id="Pointers-Example"><a href="#Pointers-Example" class="headerlink" title="Pointers Example"></a>Pointers Example</h3><p>A copy of the value is sent to a function as an argument in pass-by-value. Any changes in the function will only impact the function’s variable; it will not update the original value outside of the function scope.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User[Name: %s, Age: %d]&quot;</span>, u.Name, u.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	u.Age = age</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;</span><br><span class="line">		Name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">		Age:  <span class="number">25</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	u.SetAge(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User[Name: John, Age: <span class="number">30</span>]</span><br><span class="line">User[Name: John, Age: <span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Pass-by-pointer"><a href="#Pass-by-pointer" class="headerlink" title="Pass by pointer"></a>Pass by pointer</h3><p>In Go, everything is passed-by-value. We use pointers when we want to pass by reference and set the original value.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User[Name: %s, Age: %d]&quot;</span>, u.Name, u.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	u.Age = age</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;</span><br><span class="line">		Name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">		Age:  <span class="number">25</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	u.SetAge(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Result:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User[Name: John, Age: 30]</span><br><span class="line">User[Name: John, Age: 30]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/15/Timeout-Context-In-Go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/Timeout-Context-In-Go/" class="post-title-link" itemprop="url">Timeout-Context-In-Go</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-15 00:44:51 / 修改时间：00:54:18" itemprop="dateCreated datePublished" datetime="2022-08-15T00:44:51+09:00">2022-08-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
Go ahead ， make my day.
</blockquote>

<p>In concurrent programming with Golang, the context package is a powerful tool to manage operations like timeouts, cancelation, deadlines, etc.</p>
<p>Among these operations, context with timeout is mainly used when we want to make an external request, such as a network request or a database request. I will show you how to use it to timeout a goroutine in this post.</p>
<p>Let’s first see a simple example.</p>
<img style="margin-left: 0;" src="/images/gotimeout.jpeg">

<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Channel used to receive the result from doSomething function</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a context with a timeout of 5 seconds</span></span><br><span class="line">	ctxTimeout, cancel := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the doSomething function</span></span><br><span class="line">	<span class="keyword">go</span> doSomething(ctxTimeout, ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctxTimeout.Done():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Context cancelled: %v\n&quot;</span>, ctxTimeout.Err())</span><br><span class="line">	<span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received: %s\n&quot;</span>, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;doSomething Sleeping...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;doSomething Wake up...&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="string">&quot;Did Something&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Okay, what are we doing here?</p>
<h3 id="1-Timeout-Context"><a href="#1-Timeout-Context" class="headerlink" title="1. Timeout Context"></a>1. Timeout Context</h3><p>Creating a timeout context is very easy. We use the function WithTimeout from the context package.</p>
<p>The following example defines a timeout context that will be canceled after 3 seconds.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctxTimeout, cancel := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br></pre></td></tr></table></figure>

<p>Here, the WithTimeout takes a parent context and a duration parameter and returns a child context with a deadline set to the specified duration.</p>
<p>The parent context is returned by function Background. It is a non-nil, empty Context and is typically used by the main function as the top-level Context for incoming requests.</p>
<h3 id="2-Long-Waiting-Function"><a href="#2-Long-Waiting-Function" class="headerlink" title="2. Long Waiting Function"></a>2. Long Waiting Function</h3><p>We define a function that will execute in a separate goroutine. It will send the result to a predefined channel when finished.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;doSomething Sleeping...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;doSomething Wake up...&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="string">&quot;Did Something&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following is the predefined buffered channel.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>How to execute this function? It’s easy!</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> doSomething(ctxTimeout, ch)</span><br></pre></td></tr></table></figure>

<h3 id="3-Waiting-Orchestration"><a href="#3-Waiting-Orchestration" class="headerlink" title="3. Waiting Orchestration"></a>3. Waiting Orchestration</h3><p>We wait for the result from the predefined result or from the timeout context channel in the main function.</p>
<p>The context will automatically signal to the <code>ctxTimeout.Done</code> channel if the timeout is reached. Otherwise, we will receive the result from the ch channel.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctxTimeout.Done():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Context cancelled: %v\n&quot;</span>, ctxTimeout.Err())</span><br><span class="line">	<span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received: %s\n&quot;</span>, result)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="User-Cases"><a href="#User-Cases" class="headerlink" title="User Cases"></a>User Cases</h3><p>To better understand the context, let’s look at some real-world use cases.</p>
<h4 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opts := options.Client()</span><br><span class="line">client, _ := mongo.Connect(context.TODO(), opts)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">client.Database(<span class="string">&quot;db&quot;</span>).Collection(<span class="string">&quot;collection&quot;</span>).InsertOne(ctx, bson.M&#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="http-Get-timeout-per-request"><a href="#http-Get-timeout-per-request" class="headerlink" title="http.Get() timeout per request"></a>http.Get() timeout per request</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Microsecond*<span class="number">200</span>)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequestWithContext(ctx, http.MethodGet, <span class="string">&quot;https://google.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Error: %v&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Error: %v&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(resp.StatusCode)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://medium.com/geekculture/timeout-context-in-go-e88af0abd08d">https://medium.com/geekculture/timeout-context-in-go-e88af0abd08d</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/" class="post-title-link" itemprop="url">Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-13 17:51:47" itemprop="dateCreated datePublished" datetime="2022-08-13T17:51:47+09:00">2022-08-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-14 10:50:21" itemprop="dateModified" datetime="2022-08-14T10:50:21+09:00">2022-08-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
We become the most familiar strangers.
</blockquote>

<p>One of the well known advantage of Go is its support of concurrency. Thanks for the goroutine and channel, it makes writing high performance concurrent code become much easier. It is also fun to implement different concurrent patterns. I personally use this pattern a lot in some crawler and downloading resource concurrently, hope it helps!</p>
<p>Let start with a simple go program:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main() not waiting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> task()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is a <code>task()</code> function just sleeping for 1 second to simulate a time consuming task. And we want it to run concurrently so add a <code>go</code> keyword in front of the function call to start a goroutine.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>
<p>As expected, the program will exit immediately because the main function doesn’t wait the goroutine to finish.</p>
<p>To fix it, we can simply add a channel to block the main function:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main() waiting through channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> task(ch)</span><br><span class="line"></span><br><span class="line">	&lt;-ch <span class="comment">// block until receive something</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task finished!&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We create a non-buffered channel with empty <code>struct&#123;&#125;</code> type (since we just use the channel for signalling, the type doesn’t matters), after starting a goroutine, we immediately get the data from the channel by <code>&lt;-ch</code> , it will block the <code>main()</code> until we can get something from the channel. When the <code>task()</code> finish, it will send an empty struct data to the <code>ch</code> , at the point, the <code>main()</code> can finally get something from the <code>ch</code> and continue to run.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>

<p>read and write to a non-buffered channel are blocking operations, it can be used to synchronize and communicate with different goroutines. Whereas buffered channel doesn’t block unless the buffer is full.</p>
<p>Beside using a channel, we can also use a WaitGroup to let the main function waits, it may also be more handy if there are multiple goroutines:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main() waiting through waitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			task(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;waiting...&quot;</span>)</span><br><span class="line">	wg.Wait() <span class="comment">// block until the WaitGroup counter becomes zero</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we need to do is quite simple, just declare a <code>sync.WaitGroup</code> variable. When starting a concurrent job, call the <code>wg.Add(1)</code> to increment the counter, when to job is done, call the <code>wg.Done()</code> to decrease the counter. And at the end of <code>main()</code> we need to call <code>wg.Wait()</code> , it will block until the counter become zero.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">waiting...</span><br><span class="line">task <span class="number">0</span> finished!</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">task <span class="number">2</span> finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>
<p>The things becomes more interesting when we implement a worker pool pattern:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple worker pool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a worker keeps fetching the task and work concurrently</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> id := <span class="keyword">range</span> pool &#123;</span><br><span class="line">			task(id)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add 5 tasks to the pool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		pool &lt;- i</span><br><span class="line">		fmt.Println(<span class="string">&quot;task&quot;</span>, i, <span class="string">&quot;added!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(pool)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;waiting...&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we declare a buffered int channel <code>pool</code> , then we create a goroutine which will keep fetching the data from the pool and execute the task , this is the worker, if we want multiple workers, we can simply copy the goroutine code multiple times or wrap it with a loop. The worker is ready and blocking because nothing is inside the pool, now we need to feed some jobs to the pool. We can do that by a simple for loop and sending the loop index as a task id to the pool. As soon as the worker can get something from the pool , it will start working. Finally don’t forget to <code>close()</code> the channel if the sender(<code>main</code>) finish their work, otherwise the receiver(<code>worker</code>) will block there forever waiting for the new data comes in the channel and produce a deadlock.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task <span class="number">1</span> added!</span><br><span class="line">task <span class="number">2</span> added!</span><br><span class="line">task <span class="number">3</span> added!</span><br><span class="line">task <span class="number">4</span> added!</span><br><span class="line">task <span class="number">5</span> added!</span><br><span class="line">waiting...</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">task <span class="number">2</span> finished!</span><br><span class="line">task <span class="number">3</span> finished!</span><br><span class="line">task <span class="number">4</span> finished!</span><br><span class="line">task <span class="number">5</span> finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>

<p>In real world situation, it is more likely that we don’t know how many jobs we need to do or we just want to keep feeding the jobs unless we stop it.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// panic: send on closed channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// create a channel to capture SIGTERM, SIGINT signal</span></span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	id := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a worker keeps fetching the task and work concurrently</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> id := <span class="keyword">range</span> pool &#123;</span><br><span class="line">			task(id)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adding task to the pool infinitely</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			pool &lt;- id</span><br><span class="line">			fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;added!&quot;</span>)</span><br><span class="line">			id += <span class="number">1</span></span><br><span class="line">			time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-quit <span class="comment">// block until receive SIGTERM, SIGINT</span></span><br><span class="line">	<span class="built_in">close</span>(pool)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To achieve that, we can remove the loop condition to make it infinite loop and wrap it inside a goroutine to make it non blocking. Then we also need a channel with <code>os.Signal</code> type to block the <code>main()</code> . The program will capture <code>SIGTERM</code>, SIGINT and send to the channel by <code>signal.Notify()</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task <span class="number">1</span> added!</span><br><span class="line">task <span class="number">2</span> added!</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">task <span class="number">3</span> added!</span><br><span class="line">task <span class="number">4</span> added!</span><br><span class="line">^Ctask <span class="number">2</span> finished!</span><br><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br><span class="line">goroutine <span class="number">34</span> [running]:</span><br><span class="line">main.main.func2()</span><br><span class="line">        /Users/yk/Project/test/main.<span class="keyword">go</span>:<span class="number">77</span> +<span class="number">0x59</span></span><br><span class="line">created by main.main</span><br><span class="line">        /Users/yk/Project/test/main.<span class="keyword">go</span>:<span class="number">74</span> +<span class="number">0x185</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>What!? panic…It’s because we close the pool channel after we received the quit signal but the producer goroutine still trying to send the job to the pool channel and panic happens. We also need a way to stop the producer goroutine.</p>
<p>Worker pool graceful shutdown with WaitGroup and Context:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker pool graceful shutdown with waitGroup and context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// create a channel to capture SIGTERM, SIGINT signal</span></span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	id := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a worker keeps fetching the task and work concurrently</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> id := <span class="keyword">range</span> pool &#123;</span><br><span class="line">			task(id)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a context which listening to SIGTERM, SIGINT</span></span><br><span class="line">	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line">	<span class="keyword">defer</span> stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adding task to the pool infinitely, break until ctx.Done is closed</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;stop filling the pool!&quot;</span>)</span><br><span class="line">				<span class="built_in">close</span>(pool)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				wg.Add(<span class="number">1</span>)</span><br><span class="line">				pool &lt;- id</span><br><span class="line">				fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;added!&quot;</span>)</span><br><span class="line">				id += <span class="number">1</span></span><br><span class="line">				time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-quit</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base on the previous version, we create a context <code>ctx</code> using the <code>signal.NotifyContext()</code> function, it will close the <code>Done</code> channel of the context when the corresponding <code>SIGTERM</code>, <code>SIGINT</code> arrives. In the producer goroutine, instead of a simple for loop, we also need to add a <code>select&#123;&#125;</code> statement. If we receive <code>SIGTERM</code>, <code>SIGINT</code> , it will notify to close the <code>Done</code> channel of the context and enter the <code>case &lt;- ctx.Done()</code>: and exit the goroutine. Otherwise, it will just run the <code>default</code> case to feed jobs to the pool.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task <span class="number">1</span> added!</span><br><span class="line">task <span class="number">2</span> added!</span><br><span class="line">task <span class="number">3</span> added!</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">^Cstop filling the pool!</span><br><span class="line">task <span class="number">2</span> finished!</span><br><span class="line">task <span class="number">3</span> finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>

<p>Now when we send the <code>SIGTERM</code>, <code>SIGINT</code> to the program, it will first stop feeding more jobs to the pool and exit from the producer goroutine, then it waits for the worker goroutine to finsish all the existing task, then exit the main program.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://medium.com/@yu-yk/graceful-shutdown-concurrent-go-program-with-waitgroup-and-context-33166210e170">https://medium.com/@yu-yk/graceful-shutdown-concurrent-go-program-with-waitgroup-and-context-33166210e170</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/13/Golang%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/13/Golang%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">Golang优雅的停止程序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-13 13:54:57 / 修改时间：14:04:00" itemprop="dateCreated datePublished" datetime="2022-08-13T13:54:57+09:00">2022-08-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
I wish I could be more like you.
</blockquote>

<p>To shutdown go application gracefully, you can use open source libraries or write your own code.</p>
<p>Following are popular libraries to stop go application gracefully</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/tylerb/graceful">https://github.com/tylerb/graceful</a><br><a target="_blank" rel="noopener" href="https://github.com/braintree/manners">https://github.com/braintree/manners</a></p>
</blockquote>
<p>In this article, I will explain how to write your own code to stop go app gracefully</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>make channel which can listen for signals from OS. Refer os.Signal package for more detail. os.Signal package is used to access incoming signals from OS.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gracefulStop = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br></pre></td></tr></table></figure>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Use notify method of os.Signal to register system calls. For gracefully stop. we should listen to SIGTERM and SIGINT. signal.Notify method takes two arguments 1. channel 2. constant from syscall.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal.Notify(gracefulStop, syscall.SIGTERM)</span><br><span class="line">signal.Notify(gracefulStop, syscall.SIGINT)</span><br></pre></td></tr></table></figure>

<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>Now, We needs to create Go routine to listen channel “gracefulStop” for incoming signals. the following Go routine will block until it receives signals from OS. Now, you can perform clean up your stuff it can be closing DB connections, clearing buffered channels, write something to file, etc.. In the following code, I just put wait for 2 seconds. After completing your work you need to send a signal to OS by using os.Exit function. os.Exit function takes integer argument normally, it can be 0 or 1. 0 means clean exit without any error or problem. 1 means exit with an error or some issue. The exit status will help caller to identify the last status when process end.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       sig := &lt;-gracefulStop</span><br><span class="line">       fmt.Printf(<span class="string">&quot;caught sig: %+v&quot;</span>, sig)</span><br><span class="line">       fmt.Println(<span class="string">&quot;Wait for 2 second to finish processing&quot;</span>)</span><br><span class="line">       time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">       os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="Full-Source"><a href="#Full-Source" class="headerlink" title="Full Source"></a>Full Source</h3><p>For the demo, I use simple HTTP server which will display “Server is running” message on the browser.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">       <span class="string">&quot;os&quot;</span></span><br><span class="line">       <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">       <span class="string">&quot;syscall&quot;</span></span><br><span class="line">       <span class="string">&quot;fmt&quot;</span></span><br><span class="line">       <span class="string">&quot;time&quot;</span></span><br><span class="line">       <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">       http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">              fmt.Fprint(w,<span class="string">&quot;Server is running&quot;</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="keyword">var</span> gracefulStop = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">       signal.Notify(gracefulStop, syscall.SIGTERM)</span><br><span class="line">       signal.Notify(gracefulStop, syscall.SIGINT)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">              sig := &lt;-gracefulStop</span><br><span class="line">              fmt.Printf(<span class="string">&quot;caught sig: %+v&quot;</span>, sig)</span><br><span class="line">              fmt.Println(<span class="string">&quot;Wait for 2 second to finish processing&quot;</span>)</span><br><span class="line">              time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">              os.Exit(<span class="number">0</span>)</span><br><span class="line">       &#125;()</span><br><span class="line">       http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://kpbird.medium.com/golang-gracefully-stop-application-23c2390bb212">https://kpbird.medium.com/golang-gracefully-stop-application-23c2390bb212</a><br><a target="_blank" rel="noopener" href="https://pkg.go.dev/syscall#SIGINT">https://pkg.go.dev/syscall#SIGINT</a><br><a target="_blank" rel="noopener" href="http://husobee.github.io/golang/ecs/2016/05/19/ecs-graceful-go-shutdown.html4">http://husobee.github.io/golang/ecs/2016/05/19/ecs-graceful-go-shutdown.html4</a><br><a target="_blank" rel="noopener" href="https://pkg.go.dev/net/http#Server.Shutdown">https://pkg.go.dev/net/http#Server.Shutdown</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/13/Golang%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86Unix%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/13/Golang%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86Unix%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Golang使用信号处理Unix命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-13 13:20:37 / 修改时间：13:34:57" itemprop="dateCreated datePublished" datetime="2022-08-13T13:20:37+09:00">2022-08-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
If you have no critics, you will likely have no success. 
</blockquote>

<p>Accepting and processing signals from the operating system is important for various use cases in applications.</p>
<p>While many server-side languages have complicated or tedious approaches to processing signals from the OS, with Golang applications it’s extremely intuitive. Golang’s in-built OS package provides an easy way to integrate and react to Unix signals from your Go application. Let’s see how.</p>
<h3 id="The-Premise"><a href="#The-Premise" class="headerlink" title="The Premise"></a>The Premise</h3><p>Let’s say we want to build a Golang application that when requested to shutdown prints a message saying, “Thank you for using Golang.” Let’s set up the main function that basically keeps doing some work until an exit command is provided to the application.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Doing Work&quot;</span>)</span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When you run this application and kill it by providing a kill signal from your OS (<code>Ctrl + C</code> or <code>Ctrl + Z</code>, in most cases), you may see an output similar to this one:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Doing Work</span><br><span class="line">Doing Work</span><br><span class="line">Doing Work</span><br><span class="line">Process finished with exit code <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Now, we would like to interpret this kill signal within the Golang application and process it to print out the required exit message.</p>
<h3 id="Receiving-Signals"><a href="#Receiving-Signals" class="headerlink" title="Receiving Signals"></a>Receiving Signals</h3><p>We will create a <code>channel</code> to receive the command from the OS. The OS package provides the <code>Signal</code> interface to handle signals and has OS-specific implementations.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killSignal := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>To notify <code>killSignal</code>, we use the <code>Notify</code> function provided by the <code>signal</code> package. The first parameter takes a channel of a <code>os.Signal</code>, while the next parameters accept a list of OS signals we want to notify our channel with.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.Notify(killSignal, os.Interrupt)</span><br></pre></td></tr></table></figure>

<p>Alternatively, we can notify our signal with specific commands using the syscall package.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.Notify(killSignal, syscall.SIGINT, syscall.SIGTERM)</span><br></pre></td></tr></table></figure>

<p>In order to process the signal, we’ll make our <code>main</code> function block wait for the <code>interrupt</code> signal using the <code>killSignal</code> channel. On receiving a command from the OS, we’ll print the exit message and kill the application.</p>
<p>In order to process our work loop, let’s move that into a separate <code>goroutine</code> using an anonymous function.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Doing Work&quot;</span>)</span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>While the work function runs in a separate routine, the main function will wait for the killSignal and print the exit message before exiting.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-killSignal</span><br><span class="line">fmt.Println(<span class="string">&quot;Thanks for using Golang!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h3><p>With all the components put together, the final code is this:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	killSignal := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(killSignal, os.Interrupt)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Doing Work&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-killSignal</span><br><span class="line">	fmt.Println(<span class="string">&quot;Thanks for using Golang!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>On running this, it keeps executing the work loop, and upon receiving an <code>interrupt</code> signal from the OS, it prints the required message and then exits.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Doing Work</span><br><span class="line">Doing Work</span><br><span class="line">Doing Work</span><br><span class="line">Thanks <span class="keyword">for</span> using Golang!</span><br></pre></td></tr></table></figure>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>This simple example can be extrapolated to handle many real-life scenarios, such as gracefully shutting down servers and receiving commands in command-line applications.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://betterprogramming.pub/using-signals-to-handle-unix-commands-in-golang-f09e9efb7769">https://betterprogramming.pub/using-signals-to-handle-unix-commands-in-golang-f09e9efb7769</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/03/Concurrency-in-golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨子鳄鱼 ● 外贸自建站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/03/Concurrency-in-golang/" class="post-title-link" itemprop="url">Concurrency-in-golang</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-03 11:52:23 / 修改时间：12:10:05" itemprop="dateCreated datePublished" datetime="2022-08-03T11:52:23+09:00">2022-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">
强烈谴责， 坚决制裁
</blockquote>

<p>Coming from a PHP background, I instantly fell in love with Go after checking out the syntax and building small projects with it. What stood out most to me was the simplistic approach to lower level operations in Go, ranging from references and pointers to concurrency.</p>
<p>In this article, I will share my experience with concurrency with the aid of a small tool. The program fetches issues from the xkcd comics website and downloads each URL to build an offline JSON index. At the time of writing, there are over 2500 comics (URLs) to download.</p>
<h3 id="Why-concurrency"><a href="#Why-concurrency" class="headerlink" title="Why concurrency?"></a>Why concurrency?</h3><p>Much has been written on the concurrency feature of Go so I’ll just share my experience on what I know it does for this project. As stated earlier, the xkcd website has over 2500 comics to download. To do this sequentially (that is, one at a time), it would take a long time (probably hours). If you happen to be very patient, there is still a very high chance the operation would fail due to factors such as the rate limiting feature on the website. It would not make any sense to download this resource sequentially (trust me, I tried).</p>
<p>By using a concurrent model, I was able to implement a Worker pool (to be explained later) to handle multiple HTTP requests at a time, keeping the connection alive and getting multiple results in a very short time.</p>
<p>What is this concurrent model? In Go, it is simply creating multiple goroutines to handle parts of the processes. A goroutine is Go’s way of achieving concurrency. They are functions that run concurrently with other functions. A goroutine can be compared to a lightweight thread (although it’s not a thread, as many goroutines can work on a single thread) which makes it lighter, faster and reliable. You can create as many as one million goroutines in one program. When two or more goroutines are running, they need a way to communicate with each other. That’s where channels come in.</p>
<p>To build this program, we will depend heavily on goroutines and channels, and to maintain the focus of this article, I will leave links below to explain these fundamental concepts better.</p>
<h3 id="Planning-and-Design"><a href="#Planning-and-Design" class="headerlink" title="Planning and Design"></a>Planning and Design</h3><p>The xkcd website features a JSON interface to allow external services use their API. We will be downloading the data from this interface to build our offline index.</p>
<p>Based on the above output, we can design our struct. This struct will be used as a model for what data we want to extract for JSON handling:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Month		<span class="keyword">string</span>	<span class="string">`json:&quot;month&quot;`</span></span><br><span class="line">	Num		<span class="keyword">int</span>	<span class="string">`json:&quot;num&quot;`</span></span><br><span class="line">	Link		<span class="keyword">string</span>	<span class="string">`json:&quot;link&quot;`</span></span><br><span class="line">	Year		<span class="keyword">string</span>	<span class="string">`json:&quot;year&quot;`</span></span><br><span class="line">	News		<span class="keyword">string</span>	<span class="string">`json:&quot;news&quot;`</span></span><br><span class="line">	SafeTitle	<span class="keyword">string</span> <span class="string">`json:&quot;safe_title&quot;`</span></span><br><span class="line">	Transcript	<span class="keyword">string</span>	<span class="string">`json:&quot;transcript&quot;`</span></span><br><span class="line">	Alt		<span class="keyword">string</span>	<span class="string">`json:&quot;alt&quot;`</span></span><br><span class="line">	Img		<span class="keyword">string</span>	<span class="string">`json:&quot;img&quot;`</span></span><br><span class="line">	Title		<span class="keyword">string</span>	<span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">	Day		<span class="keyword">string</span>	<span class="string">`json:&quot;day&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fetching-the-comic"><a href="#Fetching-the-comic" class="headerlink" title="Fetching the comic"></a>Fetching the comic</h3><p>Now, before we jump into concurrency, we want to establish a function that serves the core purpose of the application — fetching the comic. The function has to be independent of our architecture and give room for re-usability across the program. I’ll explain each step below:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		Timeout: <span class="number">5</span> * time.Minute,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// concatenate strings to get url; ex: https://xkcd.com/571/info.0.json</span></span><br><span class="line">	url := strings.Join([]<span class="keyword">string</span>&#123;Url, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, n), <span class="string">&quot;info.0.json&quot;</span>&#125;, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;http request: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;http err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> data Result</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// error from web service, empty struct to avoid disruption of process</span></span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">		data = Result&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;json err: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First we create a custom HTTP client and set timeout to 5 seconds. After joining the strings using the strings package, we create a new request and send it using the previously created client. If the request is successful, we decode the data from JSON into our local struct. Then we close the response body and return a pointer to the struct.</p>
<h3 id="Confirm-it-works"><a href="#Confirm-it-works" class="headerlink" title="Confirm it works"></a>Confirm it works</h3><p>So far we have implemented the core structure of the application. Let’s run this part to ensure our code works as expected. Here’s the complete code so far:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Month		<span class="keyword">string</span>	<span class="string">`json:&quot;month&quot;`</span></span><br><span class="line">	Num		<span class="keyword">int</span>	<span class="string">`json:&quot;num&quot;`</span></span><br><span class="line">	Link		<span class="keyword">string</span>	<span class="string">`json:&quot;link&quot;`</span></span><br><span class="line">	Year		<span class="keyword">string</span>	<span class="string">`json:&quot;year&quot;`</span></span><br><span class="line">	News		<span class="keyword">string</span>	<span class="string">`json:&quot;news&quot;`</span></span><br><span class="line">	SafeTitle	<span class="keyword">string</span> <span class="string">`json:&quot;safe_title&quot;`</span></span><br><span class="line">	Transcript	<span class="keyword">string</span>	<span class="string">`json:&quot;transcript&quot;`</span></span><br><span class="line">	Alt		<span class="keyword">string</span>	<span class="string">`json:&quot;alt&quot;`</span></span><br><span class="line">	Img		<span class="keyword">string</span>	<span class="string">`json:&quot;img&quot;`</span></span><br><span class="line">	Title		<span class="keyword">string</span>	<span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">	Day		<span class="keyword">string</span>	<span class="string">`json:&quot;day&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Url = <span class="string">&quot;https://xkcd.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		Timeout: <span class="number">5</span> * time.Minute,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// concatenate strings to get url; ex: https://xkcd.com/571/info.0.json</span></span><br><span class="line">	url := strings.Join([]<span class="keyword">string</span>&#123;Url, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, n), <span class="string">&quot;info.0.json&quot;</span>&#125;, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;http request: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;http err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> data Result</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// error from web service, empty struct to avoid disruption of process</span></span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">		data = Result&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;json err: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">200</span></span><br><span class="line">	result, err := fetch(n)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, result.Title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Expected output for the title is “Bill Nye”, which is the title for issue #200. You can change the issue number to verify further.</p>
<h3 id="Channels-Setup"><a href="#Channels-Setup" class="headerlink" title="Channels Setup"></a>Channels Setup</h3><p>As stated earlier, we will be creating a Worker pool to concurrently handle the operations. To do that, we have to set up buffered channels. A buffered channel is simply a channel with a specified capacity. With a buffered channel, send operations are blocked when the buffer is full and receive operations are blocked when the buffer is empty. We need this feature because in a Worker Pool, we assign multiple jobs to a number of workers and we want to ensure they are handled in an organized way. An example:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>If we have 6 workers in our worker pool, this buffered channel will ensure at every point in time, at most 6 jobs are given to the 6 workers.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> resultCollection []Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocateJobs</span><span class="params">(noOfJobs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= noOfJobs; i++ &#123;</span><br><span class="line">		jobs &lt;- Job&#123;i+<span class="number">1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After creating the buffered channels and setting up the final results variable, we created a function to allocate jobs to the jobs channel. As expected, this function will block when i = 100, which means no new job will be added until a job has been received by the worker. After all available jobs have been allocated, the jobs channel will be closed to avoid further writes.</p>
<h3 id="Create-the-Worker-pool"><a href="#Create-the-Worker-pool" class="headerlink" title="Create the Worker pool"></a>Create the Worker pool</h3><p>A worker pool maintains multiple threads (or in our case, goroutines) and waits for tasks (jobs) to be assigned to them. For example, let’s say we have 1000 jobs. We create a worker pool which spawns 100 workers. If the jobs channel is buffered at 100-capacity, the workers takes in the 100 jobs, and as some jobs are done processing, new jobs are being allocated, which goes to the workers, and so on.</p>
<p>Our worker pool will make use of Go’s WaitGroup, a synchronization primitive (type) that tells the main goroutine to wait for a collection of goroutines to finish.</p>
<p>Here’s a simple implementation for this project:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		result, err := fetch(job.number)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;error in fetching: %v\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		results &lt;- *result</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= noOfWorkers; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the code, we first define a worker function. The worker gets a job from the allocated jobs channel, processes the result, and passes the value to the results channel. In the createWorkerPool function, we use the WaitGroup primitive to set up a Worker pool. The wg.Add(1) call increments the WaitGroup counter. The counter must be zero if the program is to stop running (which is why we have the wg.Wait() call). The wg.Done() call in the worker function decrements the counter and if all is done, the control is returned to the main goroutine and the results channel is closed to prevent further writes.</p>
<h3 id="Get-the-results"><a href="#Get-the-results" class="headerlink" title="Get the results"></a>Get the results</h3><p>The results are being added to the results channel we created. However, it is buffered and can only accept 100 at a time. We need a seperate goroutine to retrieve the results and give room for other results. Here’s how we do that:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResults</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		<span class="keyword">if</span> result.Num != <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Retrieving issue #%d\n&quot;</span>, result.Num)</span><br><span class="line">			resultCollection = <span class="built_in">append</span>(resultCollection, result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the result from the results channel is valid, we append it to the results collection. We have a boolean channel named “done”; we will use it to check if all the results have been collated.</p>
<h3 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h3><p>We have a bunch of functions, variables and types declarations, but how do we put them together? Which function is executed first and why? In this last section, we will see how it all comes together.</p>
<p>Here’s the code for the main function:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// allocate jobs</span></span><br><span class="line">	noOfJobs := <span class="number">3000</span></span><br><span class="line">	<span class="keyword">go</span> allocateJobs(noOfJobs)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get results</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> getResults(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create worker pool</span></span><br><span class="line">	noOfWorkers := <span class="number">100</span></span><br><span class="line">	createWorkerPool(noOfWorkers)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for all results to be collected</span></span><br><span class="line">	&lt;-done</span><br><span class="line"></span><br><span class="line">	<span class="comment">// convert result collection to JSON</span></span><br><span class="line">	data, err := json.MarshalIndent(resultCollection, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;json err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write json data to file</span></span><br><span class="line">	err = writeToFile(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f, err := os.Create(<span class="string">&quot;xkcd.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	_, err = f.Write(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First, we allocate jobs. We use 3000 because at the time of writing, xkcd has over 2500 comic issues, and we want to make sure we get all of them.</p>
<blockquote>
<p>Exercise: Create a small program that tells you exactly how many issues are on the xkcd website, to remove the need for an estimate.</p>
</blockquote>
<ul>
<li><p>To allocate, we start a goroutine. Note that this goroutine will block once 100 jobs have been added to the channel. It will wait for another goroutine to read the jobs channel.</p>
</li>
<li><p>We start a goroutine to collect the results. Why do this now? Well, the results channel is currently empty. Trying to read data from it will block the routine, until data has been written to the channel.</p>
</li>
<li><p>That makes it 2 goroutines blocked and waiting for read and write operations.</p>
</li>
<li><p>We create the Worker pool. This spawns many workers (100 in our example) and they read from the jobs channel, and write to the results channel.</p>
</li>
<li><p>That begins to satisfy the 2 blocked goroutines we had earlier.</p>
</li>
<li><p>We get the value of the “done” boolean channel to ensure all results have been collected.</p>
</li>
<li><p>Then we convert to JSON and write the data to file.</p>
</li>
</ul>
<h3 id="Complete-Code"><a href="#Complete-Code" class="headerlink" title="Complete Code"></a>Complete Code</h3><p>Here’s a complete code for the project:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Month		<span class="keyword">string</span>	<span class="string">`json:&quot;month&quot;`</span></span><br><span class="line">	Num		<span class="keyword">int</span>	<span class="string">`json:&quot;num&quot;`</span></span><br><span class="line">	Link		<span class="keyword">string</span>	<span class="string">`json:&quot;link&quot;`</span></span><br><span class="line">	Year		<span class="keyword">string</span>	<span class="string">`json:&quot;year&quot;`</span></span><br><span class="line">	News		<span class="keyword">string</span>	<span class="string">`json:&quot;news&quot;`</span></span><br><span class="line">	SafeTitle	<span class="keyword">string</span> 	<span class="string">`json:&quot;safe_title&quot;`</span></span><br><span class="line">	Transcript	<span class="keyword">string</span>	<span class="string">`json:&quot;transcript&quot;`</span></span><br><span class="line">	Alt		<span class="keyword">string</span>	<span class="string">`json:&quot;alt&quot;`</span></span><br><span class="line">	Img		<span class="keyword">string</span>	<span class="string">`json:&quot;img&quot;`</span></span><br><span class="line">	Title		<span class="keyword">string</span>	<span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">	Day		<span class="keyword">string</span>	<span class="string">`json:&quot;day&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Url = <span class="string">&quot;https://xkcd.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		Timeout: <span class="number">5</span> * time.Minute,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// concatenate strings to get url; ex: https://xkcd.com/571/info.0.json</span></span><br><span class="line">	url := strings.Join([]<span class="keyword">string</span>&#123;Url, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, n), <span class="string">&quot;info.0.json&quot;</span>&#125;, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;http request: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;http err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> data Result</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// error from web service, empty struct to avoid disruption of process</span></span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">		data = Result&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;json err: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> resultCollection []Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocateJobs</span><span class="params">(noOfJobs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= noOfJobs; i++ &#123;</span><br><span class="line">		jobs &lt;- Job&#123;i+<span class="number">1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		result, err := fetch(job.number)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;error in fetching: %v\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		results &lt;- *result</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= noOfWorkers; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResults</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		<span class="keyword">if</span> result.Num != <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Retrieving issue #%d\n&quot;</span>, result.Num)</span><br><span class="line">			resultCollection = <span class="built_in">append</span>(resultCollection, result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// allocate jobs</span></span><br><span class="line">	noOfJobs := <span class="number">3000</span></span><br><span class="line">	<span class="keyword">go</span> allocateJobs(noOfJobs)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get results</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> getResults(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create worker pool</span></span><br><span class="line">	noOfWorkers := <span class="number">100</span></span><br><span class="line">	createWorkerPool(noOfWorkers)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for all results to be collected</span></span><br><span class="line">	&lt;-done</span><br><span class="line"></span><br><span class="line">	<span class="comment">// convert result collection to JSON</span></span><br><span class="line">	data, err := json.MarshalIndent(resultCollection, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;json err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write json data to file</span></span><br><span class="line">	err = writeToFile(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f, err := os.Create(<span class="string">&quot;xkcd.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	_, err = f.Write(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.devgenius.io/concurrency-with-sample-project-in-golang-297400beb0a4">https://blog.devgenius.io/concurrency-with-sample-project-in-golang-297400beb0a4</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lnmput@gmail.com</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
