<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"swoole.app","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="We become the most familiar strangers.   One of the well known advantage of Go is its support of concurrency. Thanks for the goroutine and channel, it makes writing high performance concurrent code b">
<meta property="og:type" content="article">
<meta property="og:title" content="Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context">
<meta property="og:url" content="https://swoole.app/2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/index.html">
<meta property="og:site_name" content="外贸独立站(日本)">
<meta property="og:description" content="We become the most familiar strangers.   One of the well known advantage of Go is its support of concurrency. Thanks for the goroutine and channel, it makes writing high performance concurrent code b">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-13T08:51:47.000Z">
<meta property="article:modified_time" content="2022-08-14T01:50:21.000Z">
<meta property="article:author" content="lnmput@gmail.com">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://swoole.app/2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://swoole.app/2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/","path":"2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/","title":"Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context | 外贸独立站(日本)</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外贸独立站(日本)</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">专注外贸独立站建设</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section">首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags" rel="section">标签</a></li>
        <li class="menu-item menu-item-读书"><a href="/read" rel="section">读书</a></li>
        <li class="menu-item menu-item-翻译"><a href="/tags/translate" rel="section">翻译</a></li>
        <li class="menu-item menu-item-关于我"><a href="/about" rel="section">关于我</a></li>
        <li class="menu-item menu-item-外贸站"><a href="/site" rel="section">外贸站</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lnmput@gmail.com"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">lnmput@gmail.com</p>
  <div class="site-description" itemprop="description">要么庸俗，要么孤独</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">415</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">134</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://octobercms.com/" title="octobercms → https:&#x2F;&#x2F;octobercms.com&#x2F;" rel="noopener" target="_blank">octobercms</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://medium.com/" title="medium → https:&#x2F;&#x2F;medium.com&#x2F;" rel="noopener" target="_blank">medium</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lnmput" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swoole.app/2022/08/13/Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lnmput@gmail.com">
      <meta itemprop="description" content="要么庸俗，要么孤独">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外贸独立站(日本)">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Graceful-shutdown-concurrent-Go-program-with-WaitGroup-and-Context
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-13 17:51:47" itemprop="dateCreated datePublished" datetime="2022-08-13T17:51:47+09:00">2022-08-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-14 10:50:21" itemprop="dateModified" datetime="2022-08-14T10:50:21+09:00">2022-08-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote class="blockquote-center">
We become the most familiar strangers.
</blockquote>

<p>One of the well known advantage of Go is its support of concurrency. Thanks for the goroutine and channel, it makes writing high performance concurrent code become much easier. It is also fun to implement different concurrent patterns. I personally use this pattern a lot in some crawler and downloading resource concurrently, hope it helps!</p>
<p>Let start with a simple go program:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main() not waiting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> task()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is a <code>task()</code> function just sleeping for 1 second to simulate a time consuming task. And we want it to run concurrently so add a <code>go</code> keyword in front of the function call to start a goroutine.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>
<p>As expected, the program will exit immediately because the main function doesn’t wait the goroutine to finish.</p>
<p>To fix it, we can simply add a channel to block the main function:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main() waiting through channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> task(ch)</span><br><span class="line"></span><br><span class="line">	&lt;-ch <span class="comment">// block until receive something</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task finished!&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We create a non-buffered channel with empty <code>struct&#123;&#125;</code> type (since we just use the channel for signalling, the type doesn’t matters), after starting a goroutine, we immediately get the data from the channel by <code>&lt;-ch</code> , it will block the <code>main()</code> until we can get something from the channel. When the <code>task()</code> finish, it will send an empty struct data to the <code>ch</code> , at the point, the <code>main()</code> can finally get something from the <code>ch</code> and continue to run.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>

<p>read and write to a non-buffered channel are blocking operations, it can be used to synchronize and communicate with different goroutines. Whereas buffered channel doesn’t block unless the buffer is full.</p>
<p>Beside using a channel, we can also use a WaitGroup to let the main function waits, it may also be more handy if there are multiple goroutines:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main() waiting through waitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			task(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;waiting...&quot;</span>)</span><br><span class="line">	wg.Wait() <span class="comment">// block until the WaitGroup counter becomes zero</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we need to do is quite simple, just declare a <code>sync.WaitGroup</code> variable. When starting a concurrent job, call the <code>wg.Add(1)</code> to increment the counter, when to job is done, call the <code>wg.Done()</code> to decrease the counter. And at the end of <code>main()</code> we need to call <code>wg.Wait()</code> , it will block until the counter become zero.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">waiting...</span><br><span class="line">task <span class="number">0</span> finished!</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">task <span class="number">2</span> finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>
<p>The things becomes more interesting when we implement a worker pool pattern:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple worker pool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a worker keeps fetching the task and work concurrently</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> id := <span class="keyword">range</span> pool &#123;</span><br><span class="line">			task(id)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add 5 tasks to the pool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		pool &lt;- i</span><br><span class="line">		fmt.Println(<span class="string">&quot;task&quot;</span>, i, <span class="string">&quot;added!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(pool)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;waiting...&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we declare a buffered int channel <code>pool</code> , then we create a goroutine which will keep fetching the data from the pool and execute the task , this is the worker, if we want multiple workers, we can simply copy the goroutine code multiple times or wrap it with a loop. The worker is ready and blocking because nothing is inside the pool, now we need to feed some jobs to the pool. We can do that by a simple for loop and sending the loop index as a task id to the pool. As soon as the worker can get something from the pool , it will start working. Finally don’t forget to <code>close()</code> the channel if the sender(<code>main</code>) finish their work, otherwise the receiver(<code>worker</code>) will block there forever waiting for the new data comes in the channel and produce a deadlock.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task <span class="number">1</span> added!</span><br><span class="line">task <span class="number">2</span> added!</span><br><span class="line">task <span class="number">3</span> added!</span><br><span class="line">task <span class="number">4</span> added!</span><br><span class="line">task <span class="number">5</span> added!</span><br><span class="line">waiting...</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">task <span class="number">2</span> finished!</span><br><span class="line">task <span class="number">3</span> finished!</span><br><span class="line">task <span class="number">4</span> finished!</span><br><span class="line">task <span class="number">5</span> finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>

<p>In real world situation, it is more likely that we don’t know how many jobs we need to do or we just want to keep feeding the jobs unless we stop it.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// panic: send on closed channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// create a channel to capture SIGTERM, SIGINT signal</span></span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	id := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a worker keeps fetching the task and work concurrently</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> id := <span class="keyword">range</span> pool &#123;</span><br><span class="line">			task(id)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adding task to the pool infinitely</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			pool &lt;- id</span><br><span class="line">			fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;added!&quot;</span>)</span><br><span class="line">			id += <span class="number">1</span></span><br><span class="line">			time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-quit <span class="comment">// block until receive SIGTERM, SIGINT</span></span><br><span class="line">	<span class="built_in">close</span>(pool)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To achieve that, we can remove the loop condition to make it infinite loop and wrap it inside a goroutine to make it non blocking. Then we also need a channel with <code>os.Signal</code> type to block the <code>main()</code> . The program will capture <code>SIGTERM</code>, SIGINT and send to the channel by <code>signal.Notify()</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task <span class="number">1</span> added!</span><br><span class="line">task <span class="number">2</span> added!</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">task <span class="number">3</span> added!</span><br><span class="line">task <span class="number">4</span> added!</span><br><span class="line">^Ctask <span class="number">2</span> finished!</span><br><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br><span class="line">goroutine <span class="number">34</span> [running]:</span><br><span class="line">main.main.func2()</span><br><span class="line">        /Users/yk/Project/test/main.<span class="keyword">go</span>:<span class="number">77</span> +<span class="number">0x59</span></span><br><span class="line">created by main.main</span><br><span class="line">        /Users/yk/Project/test/main.<span class="keyword">go</span>:<span class="number">74</span> +<span class="number">0x185</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>What!? panic…It’s because we close the pool channel after we received the quit signal but the producer goroutine still trying to send the job to the pool channel and panic happens. We also need a way to stop the producer goroutine.</p>
<p>Worker pool graceful shutdown with WaitGroup and Context:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker pool graceful shutdown with waitGroup and context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// create a channel to capture SIGTERM, SIGINT signal</span></span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	id := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a worker keeps fetching the task and work concurrently</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> id := <span class="keyword">range</span> pool &#123;</span><br><span class="line">			task(id)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a context which listening to SIGTERM, SIGINT</span></span><br><span class="line">	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line">	<span class="keyword">defer</span> stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adding task to the pool infinitely, break until ctx.Done is closed</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;stop filling the pool!&quot;</span>)</span><br><span class="line">				<span class="built_in">close</span>(pool)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				wg.Add(<span class="number">1</span>)</span><br><span class="line">				pool &lt;- id</span><br><span class="line">				fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;added!&quot;</span>)</span><br><span class="line">				id += <span class="number">1</span></span><br><span class="line">				time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-quit</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;task&quot;</span>, id, <span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base on the previous version, we create a context <code>ctx</code> using the <code>signal.NotifyContext()</code> function, it will close the <code>Done</code> channel of the context when the corresponding <code>SIGTERM</code>, <code>SIGINT</code> arrives. In the producer goroutine, instead of a simple for loop, we also need to add a <code>select&#123;&#125;</code> statement. If we receive <code>SIGTERM</code>, <code>SIGINT</code> , it will notify to close the <code>Done</code> channel of the context and enter the <code>case &lt;- ctx.Done()</code>: and exit the goroutine. Otherwise, it will just run the <code>default</code> case to feed jobs to the pool.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">task <span class="number">1</span> added!</span><br><span class="line">task <span class="number">2</span> added!</span><br><span class="line">task <span class="number">3</span> added!</span><br><span class="line">task <span class="number">1</span> finished!</span><br><span class="line">^Cstop filling the pool!</span><br><span class="line">task <span class="number">2</span> finished!</span><br><span class="line">task <span class="number">3</span> finished!</span><br><span class="line">main exiting...</span><br></pre></td></tr></table></figure>

<p>Now when we send the <code>SIGTERM</code>, <code>SIGINT</code> to the program, it will first stop feeding more jobs to the pool and exit from the producer goroutine, then it waits for the worker goroutine to finsish all the existing task, then exit the main program.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://medium.com/@yu-yk/graceful-shutdown-concurrent-go-program-with-waitgroup-and-context-33166210e170">https://medium.com/@yu-yk/graceful-shutdown-concurrent-go-program-with-waitgroup-and-context-33166210e170</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/13/Golang%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%A8%8B%E5%BA%8F/" rel="prev" title="Golang优雅的停止程序">
                  <i class="fa fa-chevron-left"></i> Golang优雅的停止程序
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/15/Timeout-Context-In-Go/" rel="next" title="Timeout-Context-In-Go">
                  Timeout-Context-In-Go <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lnmput@gmail.com</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
